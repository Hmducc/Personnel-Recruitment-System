import { useEventCallback, useFirstMount, useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-utilities';
import * as React from 'react';
import { PresenceGroupChildContext } from '../contexts/PresenceGroupChildContext';
import { useIsReducedMotion } from '../hooks/useIsReducedMotion';
import { useMotionImperativeRef } from '../hooks/useMotionImperativeRef';
import { useMountedState } from '../hooks/useMountedState';
import { animate } from '../utils/animate';
import { getChildElement } from '../utils/getChildElement';
function shouldSkipAnimation(appear, isFirstMount, visible) {
    return !appear && isFirstMount && visible;
}
export function createPresenceComponent(motion) {
    const Presence = (props)=>{
        const itemContext = React.useContext(PresenceGroupChildContext);
        const { appear, children, imperativeRef, onMotionFinish, visible, unmountOnExit } = {
            ...itemContext,
            ...props
        };
        const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
        const child = getChildElement(children);
        const animationRef = useMotionImperativeRef(imperativeRef);
        const elementRef = React.useRef();
        const ref = useMergedRefs(elementRef, child.ref);
        const optionsRef = React.useRef({});
        const isFirstMount = useFirstMount();
        const isReducedMotion = useIsReducedMotion();
        const onEnterFinish = useEventCallback((event)=>{
            onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(event, {
                event,
                type: 'animation',
                direction: 'enter'
            });
        });
        const onExitFinish = useEventCallback((event)=>{
            onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(event, {
                event,
                type: 'animation',
                direction: 'exit'
            });
            if (unmountOnExit) {
                setMounted(false);
                itemContext === null || itemContext === void 0 ? void 0 : itemContext.onExit();
            }
        });
        useIsomorphicLayoutEffect(()=>{
            optionsRef.current = {
                appear
            };
        });
        useIsomorphicLayoutEffect(()=>{
            if (!elementRef.current || shouldSkipAnimation(optionsRef.current.appear, isFirstMount, visible)) {
                return;
            }
            const presenceDefinition = typeof motion === 'function' ? motion(elementRef.current) : motion;
            const { keyframes, ...options } = visible ? presenceDefinition.enter : presenceDefinition.exit;
            const animation = animate(elementRef.current, keyframes, {
                fill: 'forwards',
                ...options,
                ...isReducedMotion() && {
                    duration: 1
                }
            });
            if (!animation) {
                return;
            }
            if (!visible && isFirstMount) {
                // Heads up!
                // .finish() is used there to skip animation on first mount, but apply animation styles immediately
                animation.finish();
                return;
            }
            animationRef.current = animation;
            animation.onfinish = visible ? onEnterFinish : onExitFinish;
            return ()=>{
                animation.cancel();
            };
        }, // Excluding `isFirstMount` from deps to prevent re-triggering the animation on subsequent renders
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
            animationRef,
            isReducedMotion,
            onEnterFinish,
            onExitFinish,
            visible
        ]);
        if (mounted) {
            return React.cloneElement(child, {
                ref
            });
        }
        return null;
    };
    return Presence;
}
