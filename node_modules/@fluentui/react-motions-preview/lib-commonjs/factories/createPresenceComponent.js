"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createPresenceComponent", {
    enumerable: true,
    get: function() {
        return createPresenceComponent;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _reactutilities = require("@fluentui/react-utilities");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _PresenceGroupChildContext = require("../contexts/PresenceGroupChildContext");
const _useIsReducedMotion = require("../hooks/useIsReducedMotion");
const _useMotionImperativeRef = require("../hooks/useMotionImperativeRef");
const _useMountedState = require("../hooks/useMountedState");
const _animate = require("../utils/animate");
const _getChildElement = require("../utils/getChildElement");
function shouldSkipAnimation(appear, isFirstMount, visible) {
    return !appear && isFirstMount && visible;
}
function createPresenceComponent(motion) {
    const Presence = (props)=>{
        const itemContext = _react.useContext(_PresenceGroupChildContext.PresenceGroupChildContext);
        const { appear, children, imperativeRef, onMotionFinish, visible, unmountOnExit } = {
            ...itemContext,
            ...props
        };
        const [mounted, setMounted] = (0, _useMountedState.useMountedState)(visible, unmountOnExit);
        const child = (0, _getChildElement.getChildElement)(children);
        const animationRef = (0, _useMotionImperativeRef.useMotionImperativeRef)(imperativeRef);
        const elementRef = _react.useRef();
        const ref = (0, _reactutilities.useMergedRefs)(elementRef, child.ref);
        const optionsRef = _react.useRef({});
        const isFirstMount = (0, _reactutilities.useFirstMount)();
        const isReducedMotion = (0, _useIsReducedMotion.useIsReducedMotion)();
        const onEnterFinish = (0, _reactutilities.useEventCallback)((event)=>{
            onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(event, {
                event,
                type: 'animation',
                direction: 'enter'
            });
        });
        const onExitFinish = (0, _reactutilities.useEventCallback)((event)=>{
            onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(event, {
                event,
                type: 'animation',
                direction: 'exit'
            });
            if (unmountOnExit) {
                setMounted(false);
                itemContext === null || itemContext === void 0 ? void 0 : itemContext.onExit();
            }
        });
        (0, _reactutilities.useIsomorphicLayoutEffect)(()=>{
            optionsRef.current = {
                appear
            };
        });
        (0, _reactutilities.useIsomorphicLayoutEffect)(()=>{
            if (!elementRef.current || shouldSkipAnimation(optionsRef.current.appear, isFirstMount, visible)) {
                return;
            }
            const presenceDefinition = typeof motion === 'function' ? motion(elementRef.current) : motion;
            const { keyframes, ...options } = visible ? presenceDefinition.enter : presenceDefinition.exit;
            const animation = (0, _animate.animate)(elementRef.current, keyframes, {
                fill: 'forwards',
                ...options,
                ...isReducedMotion() && {
                    duration: 1
                }
            });
            if (!animation) {
                return;
            }
            if (!visible && isFirstMount) {
                // Heads up!
                // .finish() is used there to skip animation on first mount, but apply animation styles immediately
                animation.finish();
                return;
            }
            animationRef.current = animation;
            animation.onfinish = visible ? onEnterFinish : onExitFinish;
            return ()=>{
                animation.cancel();
            };
        }, // eslint-disable-next-line react-hooks/exhaustive-deps
        [
            animationRef,
            isReducedMotion,
            onEnterFinish,
            onExitFinish,
            visible
        ]);
        if (mounted) {
            return /*#__PURE__*/ _react.cloneElement(child, {
                ref
            });
        }
        return null;
    };
    return Presence;
}
